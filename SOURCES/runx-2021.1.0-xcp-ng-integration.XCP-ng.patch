From 3bba3993e90d28e826244f877f9d2945c3d867c1 Mon Sep 17 00:00:00 2001
From: Ronan Abhamon <ronan.abhamon@vates.fr>
Date: Mon, 16 Aug 2021 12:00:05 +0200
Subject: [PATCH] XCP-ng integration

Signed-off-by: Ronan Abhamon <ronan.abhamon@vates.fr>
---
 .gitignore                                    |   6 +
 DEPENDENCIES                                  |   2 +-
 README.md                                     |  12 +-
 build.sh                                      |  61 ++++--
 config/99-podman-runx.conflist                |   9 +
 config/libpod.conf                            | 157 +++++++++++++++
 config/runx.conf                              |   3 +
 docs/initrd.md                                |   2 +-
 files/container                               |  38 ++++
 files/container-wrapper                       |   5 +
 files/create                                  | 175 ++++++++++------
 files/delete                                  |  20 +-
 files/mount                                   |   7 +-
 files/pause                                   |  12 +-
 files/serial_start                            |   8 +-
 files/start                                   |   9 +-
 files/state                                   |  43 ++--
 initrd/autologin                              |   3 -
 initrd/enter                                  |  82 +++++++-
 initrd/init-initrd                            | 116 +++++++++--
 initrd/inittab                                |   2 -
 initrd/make-initrd                            |  55 ++---
 initrd/passwd                                 |   1 -
 kernel/make-kernel                            |  33 +--
 .../patches/0001-patch-pvcalls_enable.patch   | 190 ------------------
 runX => runx                                  |  40 ++--
 26 files changed, 675 insertions(+), 416 deletions(-)
 create mode 100644 .gitignore
 create mode 100644 config/99-podman-runx.conflist
 create mode 100644 config/libpod.conf
 create mode 100644 config/runx.conf
 create mode 100755 files/container
 create mode 100755 files/container-wrapper
 delete mode 100644 initrd/autologin
 delete mode 100644 initrd/inittab
 delete mode 100644 initrd/passwd
 delete mode 100644 kernel/patches/0001-patch-pvcalls_enable.patch
 rename runX => runx (67%)

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..1a96e9d
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,6 @@
+.config
+initrd/out
+kernel/out
+sendfd/*.o
+sendfd/sendfd
+target
diff --git a/DEPENDENCIES b/DEPENDENCIES
index fa4d900..3c3c322 100644
--- a/DEPENDENCIES
+++ b/DEPENDENCIES
@@ -1,5 +1,5 @@
 Please make sure you have the following installed on your system, they
-are required by runX:
+are required by runx:
 
 run time:
 xen tools (xl) >= 4.9
diff --git a/README.md b/README.md
index 2459f5e..6843e36 100644
--- a/README.md
+++ b/README.md
@@ -60,20 +60,20 @@ Use the following example config stanza in your
 /etc/containerd/config.toml config file to choose RunX as OCI-runtime:
 
     [plugins.linux]
-         runtime="/usr/sbin/runX"
+         runtime="/usr/bin/runx"
 
 - containerd 1.3.x
 
 There does not seem to be a way to configure containerd so that it runs
-runX instead of runc. You might have to:
+runx instead of runc. You might have to:
 
-    mv /usr/sbin/runX /usr/bin/runc
+    mv /usr/bin/runx /usr/bin/runc
 
 - containerd 1.4.x
 
 Pass "--runc-binary" to ctr run:
 
-    ctr run --runc-binary=/usr/sbin/runX
+    ctr run --runc-binary=/usr/bin/runx
 
 
 
@@ -83,7 +83,7 @@ Networking Configuration
 To get bridge based networking working, you need to include the containerd
 option '--env NETCONF="/path/to/cni/file,name[,IP]"', where:
     - NETCONF is the environmental varable we use to pass info from containerd
-      to runX
+      to runx
     - /path/to/cni/file is the cni v2.0 file used to describe the interface
     - name is the name of the cni interface
     - [,IP] is the optional IP if static addresses are used, otherwise DHCP
@@ -120,7 +120,7 @@ An example cni file is:
 Container Filesystem Binds
 --------------------------
 
-Currently runX only supports filesystem binds.  The defaults are bind and RW.
+Currently runx only supports filesystem binds.  The defaults are bind and RW.
 You can also pass any -o arguement mount uses.  Now you use them in containerd
 like:
 
diff --git a/build.sh b/build.sh
index b122689..a1570f3 100755
--- a/build.sh
+++ b/build.sh
@@ -15,10 +15,35 @@
 set -e
 set -o pipefail
 
-# Path to statically built busybox binary i.e.
-# busybox=/usr/bin/busybox-static-aarch64
+execs="start delete state serial_start create pause mount container container-wrapper"
 
-execs="start delete state serial_start create pause mount"
+kernel_path=""
+busybox_path=""
+params=""
+
+while (( "$#" )); do
+    case "$1" in
+        --kernel-path)
+            kernel_path=$2
+            shift
+            shift
+            ;;
+        --busybox-path)
+            busybox_path=$2
+            shift
+            shift
+            ;;
+        -*|--*=)
+            echo "Unknown option: $1" >&2
+            exit 1
+            ;;
+        *)
+            params="$1"
+            shift
+            ;;
+    esac
+done
+set -- "${params[@]}"
 
 # Clean the repo, but save the vendor area
 if [ "x${1:-}" != "x" ] && [ "clean" == "$1" ]; then
@@ -34,6 +59,11 @@ if [ "x${1:-}" != "x" ] && [ "clean" == "$1" ]; then
     exit 0
 fi
 
+if [ -z "$kernel_path" ] || [ -z "$busybox_path" ]; then
+    echo "Expected kernel and busybox paths." >&2
+    exit 1
+fi
+
 # Support cross-compiling via ARCH variable
 if [[ -z "$ARCH" ]]
 then
@@ -53,27 +83,30 @@ else
     exit 1
 fi
 
-mkdir -p target/usr/share/runX
+mkdir -p target/usr/share/runx
 for i in $execs; do
-    cp files/$i target/usr/share/runX
+    cp files/$i target/usr/share/runx
 done
 
+mkdir -p target/etc
+cp config/runx.conf target/etc
+
 cd sendfd
 make
 cd ..
-cp sendfd/sendfd target/usr/share/runX/
+cp sendfd/sendfd target/usr/share/runx/
 
-mkdir -p target/usr/sbin
-cp runX target/usr/sbin
+mkdir -p target/usr/bin
+cp runx target/usr/bin
 
 # Build the kernel and initrd
-if test \! -f target/usr/share/runX/kernel
+if test \! -f target/usr/share/runx/kernel
 then
-    kernel/make-kernel
-    cp kernel/out/kernel target/usr/share/runX
+    kernel/make-kernel "$kernel_path"
+    cp kernel/out/kernel target/usr/share/runx
 fi
-if test \! -f target/usr/share/runX/initrd
+if test \! -f target/usr/share/runx/initrd
 then
-    initrd/make-initrd
-    cp initrd/out/initrd target/usr/share/runX
+    initrd/make-initrd "$busybox_path"
+    cp initrd/out/initrd target/usr/share/runx
 fi
diff --git a/config/99-podman-runx.conflist b/config/99-podman-runx.conflist
new file mode 100644
index 0000000..fcaa102
--- /dev/null
+++ b/config/99-podman-runx.conflist
@@ -0,0 +1,9 @@
+{
+    "cniVersion": "0.4.0",
+    "name": "runx",
+    "plugins": [
+        {
+            "type": "loopback"
+        }
+    ]
+}
diff --git a/config/libpod.conf b/config/libpod.conf
new file mode 100644
index 0000000..cef3fb7
--- /dev/null
+++ b/config/libpod.conf
@@ -0,0 +1,157 @@
+# libpod.conf is the default configuration file for all tools using libpod to
+# manage containers
+
+# Default transport method for pulling and pushing for images
+image_default_transport = "docker://"
+
+# Paths to look for the conmon container manager binary.
+# If the paths are empty or no valid path was found, then the `$PATH`
+# environment variable will be used as the fallback.
+conmon_path = [
+            "/usr/libexec/podman/conmon",
+            "/usr/local/libexec/podman/conmon",
+            "/usr/local/lib/podman/conmon",
+            "/usr/bin/conmon",
+            "/usr/sbin/conmon",
+            "/usr/local/bin/conmon",
+            "/usr/local/sbin/conmon",
+            "/run/current-system/sw/bin/conmon",
+]
+
+# Environment variables to pass into conmon
+conmon_env_vars = [
+                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
+]
+
+# CGroup Manager - valid values are "systemd" and "cgroupfs"
+cgroup_manager = "systemd"
+
+# Container init binary
+#init_path = "/usr/libexec/podman/catatonit"
+
+# Directory for persistent libpod files (database, etc)
+# By default, this will be configured relative to where containers/storage
+# stores containers
+# Uncomment to change location from this default
+#static_dir = "/var/lib/containers/storage/libpod"
+
+# Directory for temporary files. Must be tmpfs (wiped after reboot)
+tmp_dir = "/var/run/libpod"
+
+# Maximum size of log files (in bytes)
+# -1 is unlimited
+max_log_size = -1
+
+# Whether to use chroot instead of pivot_root in the runtime
+no_pivot_root = false
+
+# Directory containing CNI plugin configuration files
+cni_config_dir = "/etc/cni/net.d/"
+
+# Directories where the CNI plugin binaries may be located
+cni_plugin_dir = [
+               "/usr/libexec/cni",
+               "/usr/lib/cni",
+               "/usr/local/lib/cni",
+               "/opt/cni/bin"
+]
+
+# Default CNI network for libpod.
+# If multiple CNI network configs are present, libpod will use the network with
+# the name given here for containers unless explicitly overridden.
+# The default here is set to the name we set in the
+# 87-podman-bridge.conflist included in the repository.
+# Not setting this, or setting it to the empty string, will use normal CNI
+# precedence rules for selecting between multiple networks.
+cni_default_network = "runx"
+
+# Default libpod namespace
+# If libpod is joined to a namespace, it will see only containers and pods
+# that were created in the same namespace, and will create new containers and
+# pods in that namespace.
+# The default namespace is "", which corresponds to no namespace. When no
+# namespace is set, all containers and pods are visible.
+#namespace = ""
+
+# Default infra (pause) image name for pod infra containers
+infra_image = "k8s.gcr.io/pause:3.1"
+
+# Default command to run the infra container
+infra_command = "/pause"
+
+# Determines whether libpod will reserve ports on the host when they are
+# forwarded to containers. When enabled, when ports are forwarded to containers,
+# they are held open by conmon as long as the container is running, ensuring that
+# they cannot be reused by other programs on the host. However, this can cause
+# significant memory usage if a container has many ports forwarded to it.
+# Disabling this can save memory.
+#enable_port_reservation = true
+
+# Default libpod support for container labeling
+# label=true
+
+# The locking mechanism to use
+lock_type = "shm"
+
+# Number of locks available for containers and pods.
+# If this is changed, a lock renumber must be performed (e.g. with the
+# 'podman system renumber' command).
+num_locks = 2048
+
+# Directory for libpod named volumes.
+# By default, this will be configured relative to where containers/storage
+# stores containers.
+# Uncomment to change location from this default.
+#volume_path = "/var/lib/containers/storage/volumes"
+
+# Selects which logging mechanism to use for Podman events.  Valid values
+# are `journald` or `file`.
+# events_logger = "journald"
+
+# Specify the keys sequence used to detach a container.
+# Format is a single character [a-Z] or a comma separated sequence of
+# `ctrl-<value>`, where `<value>` is one of:
+# `a-z`, `@`, `^`, `[`, `\`, `]`, `^` or `_`
+#
+# detach_keys = "ctrl-p,ctrl-q"
+
+# Default OCI runtime
+runtime = "runx"
+
+# List of the OCI runtimes that support --format=json.  When json is supported
+# libpod will use it for reporting nicer errors.
+runtime_supports_json = ["runx"]
+
+# List of all the OCI runtimes that support --cgroup-manager=disable to disable
+# creation of CGroups for containers.
+runtime_supports_nocgroups = ["runx"]
+
+# Paths to look for a valid OCI runtime (runc, runv, etc)
+# If the paths are empty or no valid path was found, then the `$PATH`
+# environment variable will be used as the fallback.
+[runtimes]
+runc = [
+            "/usr/bin/runc",
+            "/usr/sbin/runc",
+            "/usr/local/bin/runc",
+            "/usr/local/sbin/runc",
+            "/sbin/runc",
+            "/bin/runc",
+            "/usr/lib/cri-o-runc/sbin/runc",
+            "/run/current-system/sw/bin/runc",
+]
+
+crun = [
+            "/usr/bin/crun",
+            "/usr/local/bin/crun",
+]
+
+runx = [
+            "/usr/bin/runx"
+]
+
+# The [runtimes] table MUST be the last thing in this file.
+# (Unless another table is added)
+# TOML does not provide a way to end a table other than a further table being
+# defined, so every key hereafter will be part of [runtimes] and not the main
+# config.
diff --git a/config/runx.conf b/config/runx.conf
new file mode 100644
index 0000000..83f7e88
--- /dev/null
+++ b/config/runx.conf
@@ -0,0 +1,3 @@
+SR_UUID=
+TEMPLATE_UUID=
+GUEST_TOOLS=
diff --git a/docs/initrd.md b/docs/initrd.md
index 92d9c10..82187a8 100644
--- a/docs/initrd.md
+++ b/docs/initrd.md
@@ -23,4 +23,4 @@ Otherwise, the three parameters are IP addresses, they can be ipv4 or ipv6. *ip*
 
 Command line
 ------------
-The container application to run and its command line arguments (command line arguments for the application) are exposed to the RunX initrd via a special text file at the *root (/)* of the container filesystem. The file is named *cmdline*. The RunX initrd reads the content of the file and uses it to find the application to run and to pass command line arguments to it.
+The container application to run and its command line arguments (command line arguments for the application) are exposed to the RunX initrd via a special text file in */run/runx/* of the container filesystem. The file is named *cmdline*. The RunX initrd reads the content of the file and uses it to find the application to run and to pass command line arguments to it.
diff --git a/files/container b/files/container
new file mode 100755
index 0000000..982162e
--- /dev/null
+++ b/files/container
@@ -0,0 +1,38 @@
+#!/usr/bin/env bash
+
+# It's probably more safe to use VM/VDI variables to destroy VM instead of
+# reading in "$crundir/xcp_vm_uuid" and "$crundir/xcp_vdi_uuid" if files are
+# removed by an external process.
+workpath="$1"
+vm_uuid="$2"
+vdi_uuid="$3"
+wrapper_pid="$4"
+container_pipe="$5"
+
+trap '' INT TERM ABRT
+
+domid=''
+read line <$container_pipe
+if [[ "$line" == 'start' ]]; then
+    domid=`list_domains | grep -i "$vm_uuid" | awk '{print $1}'`
+else
+    kill -9 $wrapper_pid
+fi
+
+if [[ $domid ]]; then
+    path=/local/domain/$domid
+    xenstore-watch $path > $container_pipe &
+    watch_pid=$!
+    while read watch ; do
+        xenstore-read $path &>/dev/null
+        if [ $? -ne 0 ]; then
+            kill $wrapper_pid
+            break
+        fi
+    done <$container_pipe
+    kill -9 $watch_pid
+fi
+
+tail --pid="$wrapper_pid" -f /dev/null
+"$workpath/delete" "$vm_uuid" "$vdi_uuid"
+wait
diff --git a/files/container-wrapper b/files/container-wrapper
new file mode 100755
index 0000000..73c2e7d
--- /dev/null
+++ b/files/container-wrapper
@@ -0,0 +1,5 @@
+#!/usr/bin/env bash
+
+sleep infinity & PID=$!
+trap "kill $PID" INT TERM
+wait
diff --git a/files/create b/files/create
index 0dcae76..e23345e 100755
--- a/files/create
+++ b/files/create
@@ -1,31 +1,25 @@
 #!/bin/bash
 
-workpath=/usr/share/runX
+workpath="$1"
+containerid="$2"
+crundir="$3"
 
-containerid="$1"
-crundir="$2"
 bundle=$( cat "$crundir"/bundle )
 pidfile=$( cat "$crundir"/pidfile )
 configfile="$bundle"/config.json
 mountpoint=$( cat "$crundir"/rootfs )
-appname=`cat $configfile | jq '.["Path"]'`
-cmdline=\"`cat $configfile | jq  -c -r '.["process"]["args"] | join("\" \"")'`\"
-env=`cat $configfile | jq  -c -r '.["process"]["env"] | join("\" \"")'`
-xlconf=""
+appname=$(cat "$configfile" | jq '.["Path"]')
+cmdline=\"$(cat "$configfile" | jq  -c -r '.["process"]["args"] | join("\" \"")')\"
+env=$(cat "$configfile" | jq  -c -r '.["process"]["env"] | join("\" \"")')
 kernel="$workpath/kernel"
 ramdisk="$workpath/initrd"
+vm_uuid_file="$crundir/xcp_vm_uuid"
+vdi_uuid_file="$crundir/xcp_vdi_uuid"
+container_pipe="$crundir/container_pipe"
+
 for i in $env
 do
-    i=$(echo $i | tr -d \")
-    if [[ $i = XLCONF=* ]]
-    then
-        xlconf=${i#XLCONF=}
-        if [[ $xlconf = $mountpoint* ]]
-        then
-            # Don't allow the container to use XLCONF
-            xlconf=""
-        fi
-    fi
+    i=$(echo "$i" | tr -d \")
     if [[ $i = RUNX_KERNEL=* ]]
     then
         kernel=${i#RUNX_KERNEL=}
@@ -38,22 +32,60 @@ do
     fi
 done
 
+sr_uuid=""
+template_uuid=""
+guest_tools=""
+for i in $( cat /etc/runx.conf )
+do
+    i=$(echo $i | tr -d \")
+    if [[ $i = SR_UUID=* ]]
+    then
+        sr_uuid=${i#SR_UUID=}
+    fi
+    if [[ $i = TEMPLATE_UUID=* ]]
+    then
+        template_uuid=${i#TEMPLATE_UUID=}
+    fi
+    if [[ $i = GUEST_TOOLS=* ]]
+    then
+        guest_tools=${i#GUEST_TOOLS=}
+        if [ -f "$guest_tools" ]; then
+            guest_tools=$(cat "$guest_tools")
+        fi
+    fi
+done
+
+sr_uuid=$( xe sr-list uuid="$sr_uuid" --minimal )
+if ! test "$sr_uuid"
+then
+    echo "no sr found"
+    exit 1
+fi
+
+template_uuid=$( xe template-list uuid="$template_uuid" --minimal )
+if ! test "$template_uuid"
+then
+    echo "no template found"
+    exit 1
+fi
+
 # netconf is file,type[,ip]
-netconf=`cat $configfile | jq  -c -r  '.["process"]["env"][] | select(contains("NETCONF"))'`
-netconf=`echo "$netconf" | awk -F "=" '{print $2}'`
+netconf=$(cat "$configfile" | jq  -c -r  '.["process"]["env"][] | select(contains("NETCONF"))')
+netconf=$(echo "$netconf" | awk -F "=" '{print $2}')
 if test "$netconf"
 then
-    netfile=`echo "$netconf" | awk -F "," '{print $1}'`
-    netname=`echo "$netconf" | awk -F "," '{print $2}'`
-    netaddr=`echo "$netconf" | awk -F "," '{print $3}'`
-    nettype=`cat $netfile | jq -c -r "select(.[\"name\"] == \"$netname\") | .[\"type\"]"`
+    netfile=$(echo "$netconf" | awk -F "," '{print $1}')
+    netname=$(echo "$netconf" | awk -F "," '{print $2}')
+    netaddr=$(echo "$netconf" | awk -F "," '{print $3}')
+    nettype=$(cat "$netfile" | jq -c -r "select(.[\"name\"] == \"$netname\") | .[\"type\"]")
 
     if test "$nettype" = "bridge"
     then
         pvcalls=0
-        bridge=`cat $netfile | jq -c -r "select(.[\"name\"] == \"$netname\") | .[\"bridge\"]"`
-        gw=`cat $netfile | jq -c -r "select(.[\"name\"] == \"$netname\") | .[\"ipam\"][\"gateway\"]"`
-        route=`cat $netfile | jq -c -r "select(.[\"name\"] == \"$netname\") | .[\"ipam\"][\"subnet\"]"`
+        bridge=$(cat "$netfile" | jq -c -r "select(.[\"name\"] == \"$netname\") | .[\"bridge\"]")
+        gw=$(cat "$netfile" | jq -c -r "select(.[\"name\"] == \"$netname\") | .[\"ipam\"][\"gateway\"]")
+        route=$(cat "$netfile" | jq -c -r "select(.[\"name\"] == \"$netname\") | .[\"ipam\"][\"subnet\"]")
+        dns=$(cat "$netfile" | jq -c -r "select(.[\"name\"] == \"$netname\") | .[\"dns\"][\"nameservers\"]")
     else
         #shouldn't get here, but if we do assume pvcalls
         pvcalls=1
@@ -62,41 +94,70 @@ else
     pvcalls=1
 fi
 
-outconfig=$crundir/xen_vm.cfg
-rm $outconfig &> /dev/null
+vm_name_label="container:$containerid"
 
-echo "kernel='$kernel'" >> $outconfig
-if test "$ramdisk"
-then
-    echo "ramdisk='$ramdisk'" >> $outconfig
-fi
-echo "memory = 1024" >> $outconfig
-echo "vcpus = 2" >> $outconfig
-echo "serial='pty'" >> $outconfig
-echo "boot='c'" >> $outconfig
-if test $pvcalls -eq 0
+vm_uuid=$(xe vm-install new-name-label="$vm_name_label" template="$template_uuid" --minimal)
+vdi_uuid=$(xe vdi-create sr-uuid="$sr_uuid" name-label="$mountpoint" virtual-size=1KiB)
+vbd_uuid=$(xe vbd-create vm-uuid="$vm_uuid" device=1 vdi-uuid="$vdi_uuid" bootable=false mode=RW type=Disk)
+
+pv_args=$(xe vm-param-get param-name=PV-args uuid=$vm_uuid)
+
+if test "$netaddr"
 then
-    echo "vif=['bridge="$bridge"']" >> $outconfig
-    if test "$netaddr"
-    then
-        echo extra=\'console=hvc0 root=9p rdinit=/bin/init ip=$netaddr gw=$gw route=$route\' >> $outconfig
-    else
-        echo extra=\'console=hvc0 root=9p rdinit=/bin/init ip=dhcp\' >> $outconfig
-    fi
+    pv_args="$pv_args ip=$netaddr gw=$gw route=$route dns=$dns bridge=$bridge"
 else
-    echo "pvcalls=['']" >> $outconfig
-    echo extra=\'console=hvc0 root=9p rdinit=/bin/init pvcalls=1\' >> $outconfig
+    pv_args="$pv_args ip=dhcp bridge=$bridge"
 fi
-echo "vfb=['vnc=1']" >> $outconfig
-echo "p9=[ 'tag=share_dir,security_model=none,path=$mountpoint' ]" >> $outconfig
-echo "name=\"$containerid\"" >> $outconfig
-if test -f "$xlconf"
-then
-    cat "$xlconf" >> $outconfig
+
+xe vm-param-set uuid="$vm_uuid" PV-args="$pv_args root=9p rdinit=/bin/init pvcalls=$pvcalls"
+xe vm-param-set uuid="$vm_uuid" PV-kernel="/boot/guest/runx/kernel"
+xe vm-param-set uuid="$vm_uuid" PV-ramdisk="/boot/guest/runx/initrd"
+
+runx_dir="$mountpoint/run/runx"
+
+# Install tools.
+if [ "$guest_tools" ]; then
+    rpm -i --prefix="$mountpoint" "$guest_tools/*.rpm"
 fi
 
-echo $cmdline > $mountpoint/cmdline
-xl create -p $outconfig > /dev/null 2>&1
+# Set command line.
+mkdir -p "$runx_dir"
+echo "$cmdline" > "$runx_dir"/cmdline
+
+# Share ENV variables.
+env_variables=$(cat "$configfile" | jq  -c -r '.["process"]["env"] | join("\n")')
+echo "$env_variables" > "$runx_dir/env"
+
+# Specify Working dir.
+working_dir=$(cat "$configfile" | jq  -c -r '.["process"]["cwd"]')
+echo -n "$working_dir" > "$runx_dir/working_dir"
+
+# Copy or bind config files.
+config_files=$(cat "$configfile" | jq -c -r '.["mounts"] | map(select(.destination == ("/etc/resolv.conf","/etc/hostname","/etc/hosts","/run/secrets")) | "\(.source);\(.destination)") | .[]')
+for config in $config_files; do
+    config_source=${config%;*}
+    config_dest=$mountpoint/${config#*;}
+
+    if [ -d "$config_source" ]; then
+        mount -o nonempty --bind "$config_source" "$config_dest"
+    elif [ -f "$config_source" ]; then
+        # I don't know why but podman creates folders by default...
+        rm -rf "$config_dest"
+        cp "$config_source" "$config_dest"
+    fi
+done
+
+echo -n "$vm_uuid" > "$vm_uuid_file"
+echo -n "$vdi_uuid" > "$vdi_uuid_file"
+
+# Idea: We start a small program called "container-wrapper" to wait for a SIGINT, SIGABORT or SIGKILL.
+# This program can be destroyed by docker using "docker kill...", when this last one is killed, a second
+# program called "container" executes "xe vm-destroy, vdi-destroy...".
+# Otherwise with only one script we can't clean and shutdown properly the VM if a SIGKILL is received.
+mkfifo "$container_pipe"
+"$workpath/container-wrapper" &
+wrapper_pid="$!"
+"$workpath/container" "$workpath" "$vm_uuid" "$vdi_uuid" "$wrapper_pid" "$container_pipe" &
 
-pid=$( ps | grep -v grep | grep "xl create -p $outconfig" | awk '{print $1}' )
-echo -n "$pid" > "$pidfile"
+# Set the PID to make Docker happy.
+echo -n "$wrapper_pid" > "$pidfile"
diff --git a/files/delete b/files/delete
index 18317b3..2dfa50f 100755
--- a/files/delete
+++ b/files/delete
@@ -1,7 +1,21 @@
 #!/bin/bash
 
-workpath=/usr/share/runX
+SHUTDOWN_TIMEOUT=30
 
-containerid="$1"
+vm_uuid=$1
+vdi_uuid=$2
 
-xl destroy $containerid &> /dev/null
+if [ "$vm_uuid" ]; then
+    timeout $SHUTDOWN_TIMEOUT xe vm-shutdown uuid="$vm_uuid" &>/dev/null
+    if [ $? -eq 124 ]; then
+        xe vm-shutdown --force uuid="$vm_uuid" &>/dev/null
+    fi
+fi
+
+if [ "$vdi_uuid" ]; then
+    xe vdi-destroy uuid="$vdi_uuid"
+fi
+
+if [ "$vm_uuid" ]; then
+    xe vm-destroy uuid="$vm_uuid"
+fi
diff --git a/files/mount b/files/mount
index 0563df2..3a774f7 100755
--- a/files/mount
+++ b/files/mount
@@ -1,13 +1,12 @@
 #!/bin/bash
 
-workpath=/usr/share/runX
 MNT_MAX_IT=30
 OPT_MAX_IT=15
 UMNT_MAX_IT=5
 
-containerid="$1"
-crundir="$2"
-op="$3"
+crundir="$1"
+op="$2"
+
 bundle=$( cat "$crundir"/bundle )
 configfile="$bundle"/config.json
 mountpoint=$( cat "$crundir"/rootfs )
diff --git a/files/pause b/files/pause
index 87a4f57..28dd11e 100755
--- a/files/pause
+++ b/files/pause
@@ -1,14 +1,18 @@
 #!/bin/bash
 
-containerid="$1"
-cmd="$2"
+workpath="$1"
+containerid="$2"
+crundir="$3"
+cmd="$4"
+
+vm_uuid=$( cat "$crundir"/xcp_vm_uuid )
 
 case "$cmd" in
 pause)
-    xl pause "$containerid"
+    xe vm-pause uuid="$vm_uuid"
     ;;
 resume)
-    xl unpause "$containerid"
+    xe vm-unpause uuid="$vm_uuid"
     ;;
 *)
     echo "pause/resume command not found"
diff --git a/files/serial_start b/files/serial_start
index d5913d5..554796b 100755
--- a/files/serial_start
+++ b/files/serial_start
@@ -1,10 +1,10 @@
 #!/bin/bash
 
-containerid=$1
+vm_uuid=$1
 dev_containerd=$2
 
-domid=`xl list $containerid | tail -n 1 | awk '{print $2}'`
+domid=`list_domains | grep -i "$vm_uuid" | awk '{print $1}'`
 dev_xen=$(xenstore-read /local/domain/${domid}/console/tty)
 socat \
-	PTY,link=${dev_containerd},rawer \
-	${dev_xen},rawer
+  PTY,link=${dev_containerd},rawer \
+  ${dev_xen},rawer
diff --git a/files/start b/files/start
index 39d15e0..ffe5427 100755
--- a/files/start
+++ b/files/start
@@ -1,7 +1,10 @@
 #!/bin/bash
 
-workpath=/usr/share/runX
+workpath="$1"
+containerid="$2"
+crundir="$3"
 
-containerid="$1"
+vm_uuid=$( cat "$crundir"/xcp_vm_uuid )
 
-xl unpause "$1"
+xe vm-start uuid="$vm_uuid"
+echo -n "start" > "$crundir/container_pipe"
diff --git a/files/state b/files/state
index b666239..e624954 100755
--- a/files/state
+++ b/files/state
@@ -1,43 +1,30 @@
 #!/bin/bash
 
-containerid="$1"
-crundir="$2"
+workpath="$1"
+containerid="$2"
+crundir="$3"
+
 bundle=$( cat "$crundir"/bundle )
 pidfile=$( cat "$crundir"/pidfile )
-domid="$(xl domid "$containerid")"
 mountpoint=$( cat "$crundir"/rootfs )
+vm_uuid_file="$crundir"/vm_uuid
 
-if test "$domid"
-then
-    xenstate="$(xl list "$domid" 2> /dev/null | tail -n 1 | awk '{print$5}')"
-
-    if [[ $xenstate =~ p ]]
-    then
-        uptime="$(xl list "$domid" 2> /dev/null | tail -n 1 | awk '{print$6}')"
-        if [ $uptime = "0.0" ]
-        then
-            state="created"
-        else
-            state="paused"
-        fi
-    elif [[ $xenstate =~ r|b ]]
-    then
-        state="running"
-    else
-        state="stopped"
-    fi
-else
-    domid="$(xl list | tail -n 1 | awk '{print$2}')"
-    domid="$(expr $domid + 1)"
+vm_uuid=""
+state="halted"
 
-    state="stopped"
+if test -f "$vm_uuid_file"
+then
+  vm_uuid=$( cat "$vm_uuid_file" )
+  if test "$vm_uuid"
+  then
+    state=`xe vm-list uuid="$vm_uuid" params=power-state --minimal`
+  fi
 fi
 
+pid="0"
 if test -f "$pidfile"
 then
     pid=$( cat "$pidfile" )
-else
-    pid=$domid
 fi
 
 cat << EOF
diff --git a/initrd/autologin b/initrd/autologin
deleted file mode 100644
index c9b1092..0000000
--- a/initrd/autologin
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/sh
-
-exec /bin/login -f root
diff --git a/initrd/enter b/initrd/enter
index f0086f0..025e5fe 100644
--- a/initrd/enter
+++ b/initrd/enter
@@ -1,5 +1,79 @@
-#!/bin/sh
+#!/run/initramfs/bin/ash
 
-cmd=`cat /mnt/cmdline`
-echo Executing $cmd
-eval chroot /mnt $cmd
+BUSYBOX_DIR=/run/initramfs/bin
+CONFIG_DIR=/run/runx
+XE_DAEMON=/usr/bin/xe-daemon
+
+poweroff_handler() {
+    $BUSYBOX_DIR/kill -s TERM -1
+    $BUSYBOX_DIR/sync
+    $BUSYBOX_DIR/sleep 1
+
+    $BUSYBOX_DIR/kill -s KILL -1
+    $BUSYBOX_DIR/sync
+    $BUSYBOX_DIR/sleep 1
+
+    $BUSYBOX_DIR/umount -a -r
+    $BUSYBOX_DIR/swapoff -a
+    $BUSYBOX_DIR/poweroff -f
+}
+
+trap '' INT
+trap poweroff_handler 0 USR1 USR2 TERM
+
+export $($BUSYBOX_DIR/cat $CONFIG_DIR/env | $BUSYBOX_DIR/xargs)
+
+if [ "$HOSTNAME" ]; then
+    $BUSYBOX_DIR/hostname "$HOSTNAME"
+fi
+
+# Run guest tools.
+distro="runx"
+major="1"
+minor="2"
+uname=$($BUSYBOX_DIR/uname -r)
+name="runx"
+
+$BUSYBOX_DIR/cat >/var/cache/xe-linux-distribution <<EOL
+os_distro="${distro}"
+os_majorver="${major}"
+os_minorver="${minor}"
+os_uname="${uname}"
+os_name="${name}"
+EOL
+
+xe_daemon_pid=""
+if [ -f "$XE_DAEMON" ]; then
+    $XE_DAEMON &
+    xe_daemon_pid=$!
+fi
+
+# Try to chdir with root user.
+working_dir=`$BUSYBOX_DIR/cat $CONFIG_DIR/working_dir`
+if [ "$working_dir" ]; then
+    cd "$working_dir" &>/dev/null
+    if [ $? -eq 0 ]; then
+        # Directory changed with success.
+        working_dir=""
+    fi
+fi
+
+# TODO: Change user/group here.
+
+# Retry chdir with new user if necessary.
+if [ "$working_dir" ]; then
+    cd "$working_dir" &>/dev/null
+    if [ $? -ne 0 ]; then
+        echo "Failed to change working dir!"
+    fi
+fi
+
+cmd=`$BUSYBOX_DIR/cat $CONFIG_DIR/cmdline`
+echo "Executing $cmd..."
+eval $cmd &
+
+if [ "$xe_daemon_pid" ]; then
+    $BUSYBOX_DIR/kill $xe_daemon_pid
+fi
+
+wait
diff --git a/initrd/init-initrd b/initrd/init-initrd
index 579559b..8297681 100755
--- a/initrd/init-initrd
+++ b/initrd/init-initrd
@@ -1,5 +1,70 @@
 #!/bin/sh
 
+# Useful to enable the possibility to use the pivot_root command.
+switch_initramfs()
+{
+    if [ ! -r /etc/initramfs_moved ]; then
+        echo "Moving root from initramfs to tmpfs..."
+        DEST=/initramfs
+        mkdir -p $DEST
+        mount -t tmpfs -o size="100%" tmpfs $DEST
+
+        for directory in /*/ ; do
+            directory=${directory%/}
+            if [ "$directory" != "$DEST" ]; then
+                cp -a $directory $DEST 2>/dev/null
+            fi
+        done
+        cp /init $DEST
+
+        touch $DEST/etc/initramfs_moved
+        exec switch_root $DEST $0
+    fi
+}
+
+switch_9p_root()
+{
+    new_root=$1
+    echo "Switching root $1..."
+
+    umount /proc
+    umount /sys
+
+    mkdir -p $new_root/run/initramfs
+
+    BUSYBOX_DIR=/run/initramfs/bin
+
+    # Replace poweroff binary because it is called by a PV hypercall when xe vm-shutdown command is executed.
+    # In many cases the default poweroff binary of the 9pfs depends on systemd or another program, but we don't use it.
+    mkdir -p $new_root/sbin
+    rm $new_root/sbin/poweroff 2>/dev/null
+    ln -s $BUSYBOX_DIR/busybox $new_root/sbin/poweroff
+
+    # Do the same thing for halt and reboot
+    rm $new_root/sbin/halt 2>/dev/null
+    rm $new_root/sbin/reboot 2>/dev/null
+    ln -s $BUSYBOX_DIR/busybox $new_root/sbin/halt
+    ln -s $BUSYBOX_DIR/busybox $new_root/sbin/reboot
+
+    # Relink some commands used in enter script.
+    # Relinking all commands has a cost of many seconds, so we do that only on required commands.
+    for binary in ash cat chroot getty hostname kill poweroff sleep swapoff sync umount uname xargs ; do
+        ln -s -f $BUSYBOX_DIR/busybox /bin/$binary
+    done
+
+    cd $new_root
+    pivot_root . $new_root/run/initramfs
+    cd /
+
+    exec $BUSYBOX_DIR/chroot . $BUSYBOX_DIR/getty -n -l $BUSYBOX_DIR/enter 115200 hvc0
+
+    $BUSYBOX_DIR/ash # Fallback if we can't execute the command.
+}
+
+# ==============================================================================
+
+switch_initramfs
+
 mount -t proc proc /proc
 mount -t sysfs sysfs /sys
 mount -t devtmpfs devtmpfs /dev
@@ -29,27 +94,36 @@ mount -o bind /proc /mnt/proc
 ip=`cat /proc/cmdline | grep -o '\bip=[^ ]*' | cut -d = -f 2`
 gw=`cat /proc/cmdline | grep -o '\bgw=[^ ]*' | cut -d = -f 2`
 route=`cat /proc/cmdline | grep -o '\broute=[^ ]*' | cut -d = -f 2`
+dns=`cat /proc/cmdline | grep -o '\bdns=[^ ]*' | cut -d = -f 2`
 if test "$ip"
 then
-	# ipv4
-	if [ "$ip" != "${ip#*[0-9].[0-9]}" ]
-	then
-		ifconfig eth0 $ip up
-		if [ "$route" ] && [ "$gw" ]
-		then
-			route add -net $route gw $gw eth0
-		fi
-		mkdir -p /mnt/etc
-		echo "nameserver 8.8.8.8" > /mnt/etc/resolv.conf
-	# ipv6
-	elif [ "$ip" != "${ip#*:[0-9a-fA-F]}" ]
-	then
-		ifconfig eth0 add $ip up
-		if [ "$route" ] && [ "$gw" ]
-		then
-			route -A inet6 add $route gw $gw eth0
-		fi
-		mkdir -p /mnt/etc
-		echo "nameserver 2001:4860:4860::8888" > /mnt/etc/resolv.conf
-	fi
+    [ -z "$bridge" ] && bridge="eth0"
+
+    # ipv4
+    if [ "$ip" != "${ip#*[0-9].[0-9]}" ]
+    then
+        ip link set dev "$bridge" up
+        ip addr add "$ip" dev "$bridge"
+        if [ "$route" ] && [ "$gw" ]
+        then
+            route add -net $route gw $gw "$bridge"
+        fi
+        mkdir -p /mnt/etc
+        [ -z "$dns" ] && dns="8.8.8.8"
+        echo "nameserver $dns" > /mnt/etc/resolv.conf
+    # ipv6
+    elif [ "$ip" != "${ip#*:[0-9a-fA-F]}" ]
+    then
+        ip link set dev "$bridge" up
+        ip addr add "$ip" dev "$bridge"
+        if [ "$route" ] && [ "$gw" ]
+        then
+            route -A inet6 add $route gw $gw "$bridge"
+        fi
+        mkdir -p /mnt/etc
+        [ -z "$dns" ] && dns="2001:4860:4860::8888"
+        echo "nameserver $dns" > /mnt/etc/resolv.conf
+    fi
 fi
+
+switch_9p_root /mnt
diff --git a/initrd/inittab b/initrd/inittab
deleted file mode 100644
index cb26851..0000000
--- a/initrd/inittab
+++ /dev/null
@@ -1,2 +0,0 @@
-::sysinit:/etc/init.d/rcS
-hvc0::respawn:/bin/getty -n -l /bin/autologin 115200 hvc0
diff --git a/initrd/make-initrd b/initrd/make-initrd
index 21170e8..3fe752f 100755
--- a/initrd/make-initrd
+++ b/initrd/make-initrd
@@ -1,7 +1,12 @@
 #!/bin/bash
 
+busybox_path="$1"
+if [ -z "$busybox_path" ]; then
+    echo "Cannot make initrd, path is empty." >&2
+    exit 1
+fi
+
 base="`pwd`/initrd"
-builddir="$base"/build
 outpath="$base"/out
 tmpdir=`mktemp -d`
 tmpfile=`mktemp`
@@ -9,34 +14,19 @@ initrd=$outpath/initrd
 init="$base"/init-initrd
 rm -rf $tmpdir
 
+busybox_src_config="$base"/busybox.config
+busybox="$busybox_path/busybox"
 
-if test -z "$busybox"
-then
-    busybox_version=1.32.0
-    busybox_name=busybox-$busybox_version
-    busybox_tarball="$busybox_name".tar.bz2
-    busybox_url="https://busybox.net/downloads/""$busybox_tarball"
-    busybox_src_config="$base"/busybox.config
-    busybox_image="$builddir"/"$busybox_name"/busybox
-    
-    rm -rf $outpath
-    mkdir -p $outpath
-    mkdir -p $builddir
-    
-    if [[ ! -f $builddir/$busybox_tarball ]]
-    then
-        wget -O $builddir/$busybox_tarball --tries=20 $busybox_url
-    fi
-    if [[ ! -d $builddir/$busybox_name ]]
-    then
-        tar --extract --bzip2 --touch --file="$builddir/$busybox_tarball" --directory="$builddir"
-    fi
-    cd $builddir/$busybox_name
-    cp $busybox_src_config .config
-    make -j "$(getconf _NPROCESSORS_ONLN)"
-    export busybox="$busybox_image"
-fi
+rm -rf $outpath
+mkdir -p $outpath
 
+old_wd=$(pwd)
+
+cd $busybox_path
+cp $busybox_src_config .config
+make -j "$(getconf _NPROCESSORS_ONLN)"
+
+cd "$old_wd"
 
 mkdir -p $tmpdir/bin
 mkdir -p $tmpdir/sbin
@@ -53,15 +43,10 @@ do
     ln -s /bin/busybox $tmpdir/bin/$i
 done
 
-mkdir -p $tmpdir/etc/init.d
-cp $init $tmpdir/etc/init.d/rcS
-chmod +x $tmpdir/etc/init.d/rcS
-
-cp "$base"/inittab $tmpdir/etc/inittab
-cp "$base"/passwd $tmpdir/etc/passwd
+cp $init $tmpdir/init # Busybox search a init file at the root when switch_root is called.
+chmod +x $tmpdir/init
+ln -s -f /init $tmpdir/bin/init # Change default busybox init.
 
-cp "$base"/autologin $tmpdir/bin
-chmod +x $tmpdir/bin/autologin
 cp "$base"/enter $tmpdir/bin
 chmod +x $tmpdir/bin/enter
 
diff --git a/initrd/passwd b/initrd/passwd
deleted file mode 100644
index 69a2e2d..0000000
--- a/initrd/passwd
+++ /dev/null
@@ -1 +0,0 @@
-root::0:0:root:/:/bin/enter
diff --git a/kernel/make-kernel b/kernel/make-kernel
index 538adb7..7a777ed 100755
--- a/kernel/make-kernel
+++ b/kernel/make-kernel
@@ -1,5 +1,11 @@
 #!/bin/bash -x
 
+kernel_path="$1"
+if [ -z "$kernel_path" ]; then
+    echo "Cannot make kernel, path is empty." >&2
+    exit 1
+fi
+
 if [[ $ARCH = "x86"  ]]
 then
     image="bzImage"
@@ -13,37 +19,20 @@ fi
 
 kernel_stuffdir=`readlink -f kernel`
 kernel_outpath=$kernel_stuffdir/out
-kernel_builddir=$kernel_stuffdir/build
 kernel_out=$kernel_outpath/kernel
 
-kernel_version=5.4
-kernel_name=linux-$kernel_version
-kernel_tarball="$kernel_name".tar.xz
-kernel_url=https://www.kernel.org/pub/linux/kernel/v5.x/"$kernel_tarball"
 kernel_src_config="$kernel_stuffdir"/cutdown-config."$ARCH"
 kernel_patchesdir="$kernel_stuffdir"/patches
-kernel_image="$kernel_builddir"/"$kernel_name"/arch/"$ARCH"/boot/"$image"
-
+kernel_image="$kernel_path"/arch/"$ARCH"/boot/"$image"
 
 rm -rf $kernel_outpath
 mkdir -p $kernel_outpath
-mkdir -p $kernel_builddir
 
-if [[ ! -f $kernel_builddir/$kernel_tarball ]]
-then
-    wget -O $kernel_builddir/$kernel_tarball --tries=20 $kernel_url
-fi
-if [[ ! -d $kernel_builddir/$kernel_name ]]
-then
-    tar --extract --xz --touch --file="$kernel_builddir/$kernel_tarball" --directory="$kernel_builddir"
-    cd $kernel_builddir/$kernel_name
-    for i in $kernel_patchesdir/*
-    do
-        patch -p1 < $i
-    done
-fi
-cd $kernel_builddir/$kernel_name
+old_wd=$(pwd)
+
+cd $kernel_path
 cp $kernel_src_config .config
 make -j "$(getconf _NPROCESSORS_ONLN)" $image
 
+cd "$old_wd"
 cp $kernel_image $kernel_out
diff --git a/kernel/patches/0001-patch-pvcalls_enable.patch b/kernel/patches/0001-patch-pvcalls_enable.patch
deleted file mode 100644
index 71b2430..0000000
--- a/kernel/patches/0001-patch-pvcalls_enable.patch
+++ /dev/null
@@ -1,190 +0,0 @@
-diff --git a/drivers/xen/Makefile b/drivers/xen/Makefile
-index 0c4efa6fe450..a8f17656d511 100644
---- a/drivers/xen/Makefile
-+++ b/drivers/xen/Makefile
-@@ -36,6 +36,7 @@ obj-$(CONFIG_XEN_SCSI_BACKEND)		+= xen-scsiback.o
- obj-$(CONFIG_XEN_AUTO_XLATE)		+= xlate_mmu.o
- obj-$(CONFIG_XEN_PVCALLS_BACKEND)	+= pvcalls-back.o
- obj-$(CONFIG_XEN_PVCALLS_FRONTEND)	+= pvcalls-front.o
-+obj-$(CONFIG_XEN_PVCALLS_FRONTEND)	+= pvcalls.o
- xen-evtchn-y				:= evtchn.o
- xen-gntdev-y				:= gntdev.o
- xen-gntdev-$(CONFIG_XEN_GNTDEV_DMABUF)	+= gntdev-dmabuf.o
-diff --git a/drivers/xen/pvcalls.c b/drivers/xen/pvcalls.c
-new file mode 100644
-index 000000000000..9c758addd9c8
---- /dev/null
-+++ b/drivers/xen/pvcalls.c
-@@ -0,0 +1,129 @@
-+#include <linux/types.h>
-+#include <linux/bitops.h>
-+#include <linux/cred.h>
-+#include <linux/init.h>
-+#include <linux/io.h>
-+#include <linux/kernel.h>
-+#include <linux/kmod.h>
-+#include <linux/list.h>
-+#include <linux/miscdevice.h>
-+#include <linux/module.h>
-+#include <linux/mutex.h>
-+#include <linux/net.h>
-+#include <linux/poll.h>
-+#include <linux/skbuff.h>
-+#include <linux/smp.h>
-+#include <linux/socket.h>
-+#include <linux/stddef.h>
-+#include <linux/unistd.h>
-+#include <linux/wait.h>
-+#include <linux/workqueue.h>
-+#include <net/sock.h>
-+#include <net/inet_common.h>
-+
-+#include "pvcalls-front.h"
-+
-+static int
-+pvcalls_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
-+{
-+	int ret;
-+	ret = pvcalls_front_socket(sock);
-+	if (ret < 0)
-+		return ret;
-+	return pvcalls_front_bind(sock, addr, addr_len);
-+}
-+
-+static int pvcalls_stream_connect(struct socket *sock, struct sockaddr *addr,
-+				int addr_len, int flags)
-+{
-+	int ret;
-+	ret = pvcalls_front_socket(sock);
-+	if (ret < 0)
-+		return ret;
-+	return pvcalls_front_connect(sock, addr, addr_len, flags);
-+}
-+
-+static int pvcalls_accept(struct socket *sock, struct socket *newsock, int flags, bool kern)
-+{
-+	return pvcalls_front_accept(sock, newsock, flags);
-+}
-+
-+static int pvcalls_getname(struct socket *sock,
-+			 struct sockaddr *uaddr, int peer)
-+{
-+	DECLARE_SOCKADDR(struct sockaddr_in *, sin, uaddr);
-+
-+	sin->sin_family = AF_INET;
-+	memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
-+	return sizeof(*sin);
-+}
-+
-+static unsigned int pvcalls_poll(struct file *file, struct socket *sock,
-+			       poll_table *wait)
-+{
-+	return pvcalls_front_poll(file, sock, wait);
-+}
-+
-+static int pvcalls_listen(struct socket *sock, int backlog)
-+{
-+	return pvcalls_front_listen(sock, backlog);
-+}
-+
-+static int pvcalls_stream_sendmsg(struct socket *sock, struct msghdr *msg,
-+				size_t len)
-+{
-+	return pvcalls_front_sendmsg(sock, msg, len);
-+}
-+
-+static int
-+pvcalls_stream_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,
-+		     int flags)
-+{
-+	return pvcalls_front_recvmsg(sock, msg, len, flags);
-+}
-+
-+static int pvcalls_release(struct socket *s)
-+{
-+	return pvcalls_front_release(s);
-+}
-+
-+static int pvcalls_shutdown(struct socket *s, int h)
-+{
-+	return -ENOTSUPP;
-+}
-+
-+static int pvcalls_setsockopt(struct socket *sock, int level, int optname,
-+		    char __user *optval, unsigned int optlen)
-+{
-+	printk(KERN_DEBUG "ignoring setsockopt:0x%x\n", optname);
-+	return 0;
-+}
-+
-+const struct proto_ops pvcalls_stream_ops = {
-+	.family = PF_INET,
-+	.owner = THIS_MODULE,
-+	.release = pvcalls_release,
-+	.bind = pvcalls_bind,
-+	.connect = pvcalls_stream_connect,
-+	.socketpair = sock_no_socketpair,
-+	.accept = pvcalls_accept,
-+	.getname = pvcalls_getname,
-+	.poll = pvcalls_poll,
-+	.ioctl = sock_no_ioctl,
-+	.listen = pvcalls_listen,
-+	.shutdown = pvcalls_shutdown,
-+	.setsockopt = pvcalls_setsockopt,
-+	.getsockopt = sock_no_getsockopt,
-+	.sendmsg = pvcalls_stream_sendmsg,
-+	.recvmsg = pvcalls_stream_recvmsg,
-+	.mmap = sock_no_mmap,
-+	.sendpage = sock_no_sendpage,
-+};
-+
-+bool pvcalls = false;
-+static __init int xen_parse_pvcalls(char *arg)
-+{
-+       pvcalls = true;
-+       return 0;
-+}
-+early_param("pvcalls", xen_parse_pvcalls);
-diff --git a/include/xen/pvcalls.h b/include/xen/pvcalls.h
-new file mode 100644
-index 000000000000..7a6147528ebd
---- /dev/null
-+++ b/include/xen/pvcalls.h
-@@ -0,0 +1,13 @@
-+#ifndef __LINUX_NET_PVCALLS_H
-+#define __LINUX_NET_PVCALLS_H
-+
-+#include <linux/net.h>
-+
-+#ifdef CONFIG_XEN_PVCALLS_FRONTEND
-+extern bool pvcalls;
-+#else
-+#define pvcalls (0)
-+#endif
-+extern const struct proto_ops pvcalls_stream_ops;
-+
-+#endif
-diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
-index 70f92aaca411..7bdc2dbdebc7 100644
---- a/net/ipv4/af_inet.c
-+++ b/net/ipv4/af_inet.c
-@@ -118,6 +118,7 @@
- #include <net/l3mdev.h>
- 
- #include <trace/events/sock.h>
-+#include <xen/pvcalls.h>
- 
- /* The inetsw table contains everything that inet_create needs to
-  * build a new socket.
-@@ -1959,6 +1960,11 @@ static int __init inet_init(void)
- 	for (r = &inetsw[0]; r < &inetsw[SOCK_MAX]; ++r)
- 		INIT_LIST_HEAD(r);
- 
-+	if (pvcalls) {
-+		pr_info("Enabling pvcalls for AF_INET SOCK_STREAM\n");
-+		inetsw_array[0].ops = &pvcalls_stream_ops;
-+	}
-+
- 	for (q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q)
- 		inet_register_protosw(q);
- 
diff --git a/runX b/runx
similarity index 67%
rename from runX
rename to runx
index 9076934..813a1d5 100755
--- a/runX
+++ b/runx
@@ -1,7 +1,7 @@
 #!/bin/bash
 
-workpath=/usr/share/runX
-rundir=/run/runX
+workpath=/usr/share/runx/
+rundir=/run/runx
 
 guestconsole=""
 cmd=""
@@ -9,6 +9,7 @@ root=""
 bundle=""
 pidfile=""
 containerid=""
+force=false
 while (( "$#" ))
 do
     if [[ $1 = "--root" ]]
@@ -44,6 +45,12 @@ do
         shift
         continue
     fi
+    if [[ $1 = "--force" ]]
+    then
+        force=true
+        shift
+        continue
+    fi
     if [[ $1 = "--"* ]]
     then
         shift
@@ -103,29 +110,31 @@ fi
 
 if test $cmd = "state"
 then
-    $workpath/state $containerid "$crundir"
+    "$workpath/state" "$workpath" $containerid "$crundir"
 elif test $cmd = "start"
 then
-    $workpath/start $containerid
+    "$workpath/start" "$workpath" $containerid "$crundir"
 elif test $cmd = "pause"
 then
-    $workpath/pause $containerid pause
+    "$workpath/pause" "$workpath" $containerid "$crundir" pause
 elif test $cmd = "resume"
 then
-    $workpath/pause $containerid resume
+    "$workpath/pause" "$workpath" $containerid "$crundir" resume
 elif test $cmd = "kill"
 then
-    $workpath/delete $containerid
-    $workpath/mount $containerid "$crundir" unmount
+    if [ -f "$crundir/xcp_vm_uuid" ] && [ -f "$crundir/xcp_vdi_uuid" ]; then
+        "$workpath/delete" `cat "$crundir"/xcp_vm_uuid` `cat "$crundir"/xcp_vdi_uuid`
+        "$workpath/mount" "$crundir" unmount
+    fi
 elif test $cmd = "create"
 then
-    $workpath/mount $containerid "$crundir" mount
-    $workpath/create $containerid "$crundir"
+    "$workpath/mount" "$crundir" mount
+    "$workpath/create" "$workpath" $containerid "$crundir"
 
     if test "$guestconsole"
     then
-        daemonize $workpath/serial_start \
-          "$containerid" \
+        daemonize "$workpath/serial_start" \
+          `cat "$crundir"/xcp_conf` \
           "$crundir"/console_pty
         for n in 10 9 8 7 6 5 4 3 2 1; do
             if [ ! -L "$crundir"/console_pty ]; then
@@ -134,14 +143,19 @@ then
               break
             fi;
         done
-        daemonize $workpath/sendfd \
+        daemonize "$workpath/sendfd" \
           "$guestconsole" \
           "$crundir"/console_pty
     else
          echo "connect to container console with 'xl console $containerid'"
     fi
+    exit 0 # Previous test can set $? to 1...
 elif test $cmd = "delete"
 then
+    if [ -f "$crundir/xcp_vm_uuid" ] && [ -f "$crundir/xcp_vdi_uuid" ]; then
+        "$workpath/delete" `cat "$crundir"/xcp_vm_uuid` `cat "$crundir"/xcp_vdi_uuid`
+        "$workpath/mount" "$crundir" unmount
+    fi
     rm -rf "$crundir"
 else
     :
-- 
2.33.0

